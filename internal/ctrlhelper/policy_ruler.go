/*
Copyright 2025.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package ctrlhelper

import (
	"context"

	"github.com/Southclaws/fault"
	"github.com/Southclaws/fault/fctx"
	"github.com/Southclaws/fault/fmsg"
	"github.com/bojanzelic/cloudflare-zero-trust-operator/api/v4alpha1"
	"github.com/go-logr/logr"
	ctrl "sigs.k8s.io/controller-runtime"
)

// +k8s:deepcopy-gen=false

// must be implemented by [CloudflareAccessReusablePolicy] / [CloudflareAccessGroup]
type GenericAccessPolicyRuler interface {
	GetIncludeRules() *v4alpha1.CloudFlareAccessRules
	GetExcludeRules() *v4alpha1.CloudFlareAccessRules
	GetRequireRules() *v4alpha1.CloudFlareAccessRules

	GetIncludeCfIds() *v4alpha1.ResolvedCloudflareIDs
	GetExcludeCfIds() *v4alpha1.ResolvedCloudflareIDs
	GetRequireCfIds() *v4alpha1.ResolvedCloudflareIDs
}

//
//
//

// - Will navigate through [policyList] accessRules
//
// - Find named references of CRDs defined resources, which correspond to uniquely identified Cloudflare API objects (like Service Tokens, Groups...)
//
// - Try to find the associated Cloudflare object UUID which was generated by the API, and bind it to any accessRule which uses it
//
// @dev Might ask for an immediate (with error) or a later (with *ctrl.Result defined) requeue.
// @dev Requires a later Client.Status().Update() for it to be persisted
//
//nolint:gocognit
func (helper *ControllerHelper) PopulateWithCloudflareUUIDs(
	ctx context.Context,
	contextNamespace string,
	log *logr.Logger,
	policyRuler GenericAccessPolicyRuler,
) (res *ctrl.Result, err error, populated bool) {
	// declare index align rules sets with status
	ruleSets := []struct {
		rules *v4alpha1.CloudFlareAccessRules
		ids   *v4alpha1.ResolvedCloudflareIDs
	}{
		{policyRuler.GetIncludeRules(), policyRuler.GetIncludeCfIds()},
		{policyRuler.GetExcludeRules(), policyRuler.GetExcludeCfIds()},
		{policyRuler.GetRequireRules(), policyRuler.GetRequireCfIds()},
	}

	//
	for _, ruleSet := range ruleSets { //nolint:varnamelen

		//
		// Reset old resolved IDs
		//

		ruleSet.ids.AccessGroupRefCfIds = ruleSet.ids.AccessGroupRefCfIds[:0]
		ruleSet.ids.ServiceTokenRefCfIds = ruleSet.ids.ServiceTokenRefCfIds[:0]

		//
		// Access Group Refs
		//

		accessGroupRefs, err := ruleSet.rules.GetNamespacedGroupRefs(ctx, contextNamespace)
		if err != nil {
			// will retry immediately
			return nil, fault.Wrap(err, fmsg.With("issue while extracting group refs")), populated
		}
		for _, accessGroupRef := range accessGroupRefs {
			//
			accessGroup := &v4alpha1.CloudflareAccessGroup{}

			//
			if err := helper.R.Get(ctx, accessGroupRef, accessGroup); err != nil {
				// will retry immediately
				return nil, fault.Wrap(err,
					fmsg.With("unable to reference CloudflareAccessGroup"),
					fctx.With(ctx,
						"name", accessGroupRef.Name,
						"namespace", accessGroupRef.Namespace,
					),
				), populated
			}

			//
			UUID := accessGroup.GetCloudflareUUID()
			if UUID == "" {
				//
				err := fault.Newf("Undefined UUID; CloudflareAccessGroup %s - %s not ready yet", accessGroupRef.Name, accessGroupRef.Namespace)
				log.Error(err, "Issue while checking defined Cloudflare UUID")

				// will retry later (setting error here would trigger immediate retry)
				return &ctrl.Result{RequeueAfter: helper.NormalRequeueDelay}, nil, populated
			}

			//
			ruleSet.ids.AccessGroupRefCfIds = append(ruleSet.ids.AccessGroupRefCfIds, UUID)
			populated = true
		}

		//
		// Access Service Token Refs
		//

		//
		tokenRefs, err := ruleSet.rules.GetNamespacedServiceTokenRefs(ctx, contextNamespace)
		if err != nil {
			// will retry immediately
			return nil, fault.Wrap(err, fmsg.With("issue while extracting service token refs")), populated
		}
		for _, tokenRef := range tokenRefs {
			//
			serviceToken := &v4alpha1.CloudflareServiceToken{}

			//
			if err := helper.R.Get(ctx, tokenRef, serviceToken); err != nil {
				// will retry immediately
				return nil, fault.Wrap(err,
					fmsg.With("unable to reference CloudflareServiceToken"),
					fctx.With(ctx,
						"name", tokenRef.Name,
						"namespace", tokenRef.Namespace,
					),
				), populated
			}

			//
			UUID := serviceToken.GetCloudflareUUID()
			if UUID == "" {
				//
				err := fault.Newf("Undefined UUID; CloudflareServiceToken %s - %s not ready yet", tokenRef.Name, tokenRef.Namespace)
				log.Error(err, "Issue while checking defined Cloudflare UUID")

				// will retry later (setting error here would trigger immediate retry)
				return &ctrl.Result{RequeueAfter: helper.NormalRequeueDelay}, nil, populated
			}

			//
			ruleSet.ids.ServiceTokenRefCfIds = append(ruleSet.ids.ServiceTokenRefCfIds, UUID)
			populated = true
		}
	}

	// all went good
	return nil, nil, populated
}
