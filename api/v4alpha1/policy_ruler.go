/*
Copyright 2025.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v4alpha1

import (
	"context"
	"time"

	"github.com/go-logr/logr"
	"github.com/pkg/errors"
	ctrl "sigs.k8s.io/controller-runtime"
	"sigs.k8s.io/controller-runtime/pkg/client"
)

// +k8s:deepcopy-gen=false

// must be implemented by [CloudflareAccessReusablePolicy] / [CloudflareAccessGroup]
type GenericAccessPolicyRuler interface {
	GetIncludeRules() *CloudFlareAccessRules
	GetExcludeRules() *CloudFlareAccessRules
	GetRequireRules() *CloudFlareAccessRules

	GetIncludeCfIds() *ResolvedCloudflareIDs
	GetExcludeCfIds() *ResolvedCloudflareIDs
	GetRequireCfIds() *ResolvedCloudflareIDs
}

// - Will navigate through [policyList] accessRules
// - Find named references of CRDs defined resources, which correspond to uniquely identified Cloudflare API objects (like Service Tokens, Groups...)
// - Try to find the associated Cloudflare object UUID which was generated by the API, and bind it to any accessRule which uses it
//
// @dev Might ask for an immediate (with error) or a later (with *ctrl.Result defined) requeue.
//
//nolint:gocognit
func PopulateWithCloudflareUUIDs(
	ctx context.Context,
	contextNamespace string,
	log *logr.Logger,
	k8sCli client.Client,
	policyRuler GenericAccessPolicyRuler,
) (*ctrl.Result, error) {
	// declare index align rules sets with status
	managedCFRules := []*CloudFlareAccessRules{
		policyRuler.GetIncludeRules(),
		policyRuler.GetExcludeRules(),
		policyRuler.GetRequireRules(),
	}
	managedCFIds := []*ResolvedCloudflareIDs{
		policyRuler.GetIncludeCfIds(),
		policyRuler.GetExcludeCfIds(),
		policyRuler.GetRequireCfIds(),
	}

	//
	for i, rulesType := range managedCFRules { //nolint:varnamelen

		//
		//
		//

		accessGroupRefs, err := rulesType.GetNamespacedGroupRefs(contextNamespace)
		if err != nil {
			// will retry immediately
			return nil, errors.Wrapf(err, "issue while extracting group refs")
		}
		for _, accessGroupRef := range accessGroupRefs {
			//
			accessGroup := &CloudflareAccessGroup{}

			//
			if err := k8sCli.Get(ctx, accessGroupRef, accessGroup); err != nil {
				// will retry immediately
				return nil, errors.Wrapf(err, "unable to reference CloudflareAccessGroup %s - %s", accessGroupRef.Name, accessGroupRef.Namespace)
			}

			//
			if accessGroup.Status.AccessGroupID == "" {
				//
				err := errors.Errorf("Undefined UUID; CloudflareAccessGroup %s - %s not ready yet", accessGroupRef.Name, accessGroupRef.Namespace)
				log.Error(err, "Issue while checking defined Cloudflare UUID")

				// will retry later (setting error here would trigger immediate retry)
				return &ctrl.Result{RequeueAfter: 10 * time.Second}, nil
			}

			//
			managedCFIds[i].AccessGroupRefCfIds = append(managedCFIds[i].AccessGroupRefCfIds, accessGroup.Status.AccessGroupID)
		}

		//
		//
		//

		//
		tokenRefs, err := rulesType.GetNamespacedServiceTokenRefs(contextNamespace)
		if err != nil {
			// will retry immediately
			return nil, errors.Wrapf(err, "issue while extracting service token refs")
		}
		for _, tokenRef := range tokenRefs {
			//
			serviceToken := &CloudflareServiceToken{}

			//
			if err := k8sCli.Get(ctx, tokenRef, serviceToken); err != nil {
				// will retry immediately
				return nil, errors.Wrapf(err, "unable to reference CloudflareServiceToken %s - %s", tokenRef.Name, tokenRef.Namespace)
			}

			//
			if serviceToken.Status.ServiceTokenID == "" {
				//
				err := errors.Errorf("Undefined UUID; CloudflareServiceToken %s - %s not ready yet", tokenRef.Name, tokenRef.Namespace)
				log.Error(err, "Issue while checking defined Cloudflare UUID")

				// will retry later (setting error here would trigger immediate retry)
				return &ctrl.Result{RequeueAfter: 10 * time.Second}, nil
			}

			//
			managedCFIds[i].ServiceTokenRefCfIds = append(managedCFIds[i].ServiceTokenRefCfIds, serviceToken.Status.ServiceTokenID)
		}
	}

	// all went good
	return nil, nil
}
